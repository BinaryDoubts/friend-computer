var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import React from 'react';
import ReactDOM from 'react-dom';
import scrollparent from 'scrollparent';
import scrollMonitor from 'scrollmonitor';
import ReactJsonSchema from './utils/schema2element';
import entries from 'object.entries';
import values from 'object.values';
import { getData, getVars, filterASTForDocument, splitAST, translate, findWrapTargets, mapTree, evalExpression, hooks, scrollMonitorEvents } from './utils';

var updatePropsCallbacks = [];
var updateRefsCallbacks = [];
var scrollWatchers = [];
var scrollOffsets = {};
var refCache = {};
var evalContext = {};
var scrollContainer = void 0;

var getRefs = function getRefs() {
  var refs = {};
  if (!scrollContainer) {
    return;
  }

  scrollWatchers.forEach(function (watcher) {
    // left and right props assume no horizontal scrolling
    var watchItem = watcher.watchItem,
        callbacks = watcher.callbacks,
        container = watcher.container,
        recalculateLocation = watcher.recalculateLocation,
        offsets = watcher.offsets,
        watcherProps = _objectWithoutProperties(watcher, ['watchItem', 'callbacks', 'container', 'recalculateLocation', 'offsets']);

    refs[watchItem.dataset.ref] = _extends({}, watcherProps, {
      domNode: watchItem
    });
  });

  return refs;
};

var wrapperKey = 0;

var Wrapper = function (_React$PureComponent) {
  _inherits(Wrapper, _React$PureComponent);

  function Wrapper(props) {
    _classCallCheck(this, Wrapper);

    var _this = _possibleConstructorReturn(this, _React$PureComponent.call(this, props));

    _this.key = wrapperKey++;
    _this.ref = {};
    _this.onUpdateRefs = _this.onUpdateRefs.bind(_this);
    _this.onUpdateProps = _this.onUpdateProps.bind(_this);

    var vars = values(props.__vars__);
    var exps = values(props.__expr__);

    _this.usesRefs = exps.some(function (v) {
      return v.includes('refs.');
    });

    // listen for props updates IF we care about them
    if (vars.length || exps.length) {
      // called with new doc state
      // when any component calls updateProps()
      updatePropsCallbacks.push(_this.onUpdateProps);
    }

    // listen for ref updates IF we care about them
    if (props.hasHook || _this.usesRefs) {
      updateRefsCallbacks.push(_this.onUpdateRefs);
    }

    _this.state = { hasError: false, error: null };
    return _this;
  }

  Wrapper.prototype.componentDidCatch = function componentDidCatch(error, info) {
    this.setState({ hasError: true, error: error });
  };

  Wrapper.prototype.onUpdateProps = function onUpdateProps(newState, changedKeys) {
    var _props = this.props,
        __vars__ = _props.__vars__,
        __expr__ = _props.__expr__;

    // were there changes to any vars we track?
    // or vars our expressions reference?

    var shouldUpdate = changedKeys.some(function (k) {
      return values(__vars__).includes(k) || values(__expr__).some(function (expr) {
        return expr.includes(k);
      });
    });
    // if nothing we care about changed bail out and don't re-render
    if (!shouldUpdate) return;

    // update this component's state
    var nextState = {};
    // pull in the latest value for any tracked vars
    Object.keys(__vars__).forEach(function (key) {
      nextState[key] = newState[__vars__[key]];
    });
    // re-run this component's expressions using the latest doc state
    Object.keys(__expr__).forEach(function (key) {
      nextState[key] = evalExpression(newState, __expr__[key], key, evalContext);
    });
    // trigger a re-render of this component
    // and more importantly, its wrapped component
    this.setState(nextState);
  };

  Wrapper.prototype.onUpdateRefs = function onUpdateRefs(newState) {
    var __expr__ = this.props.__expr__;


    if (this.usesRefs) {
      var nextState = { refs: newState.refs };
      entries(__expr__).forEach(function (_ref) {
        var key = _ref[0],
            val = _ref[1];

        if (!key.includes('refs.')) {
          return;
        }
        nextState[key] = evalExpression(newState, val, key, evalContext);
      });

      // trigger a render with latest state
      this.setState(nextState);
    }
  };

  Wrapper.prototype.componentWillUnmount = function componentWillUnmount() {
    var propsIndex = updatePropsCallbacks.indexOf(this.onUpdateProps);
    if (propsIndex > -1) updatePropsCallbacks.splice(propsIndex, 1);

    var refsIndex = updateRefsCallbacks.indexOf(this.onUpdateRefs);
    if (refsIndex > -1) updateRefsCallbacks.splice(refsIndex, 1);
  };

  Wrapper.prototype.render = function render() {
    var _this2 = this;

    if (this.state.hasError) {
      return React.createElement(
        'div',
        { style: { border: 'solid red 1px', padding: 10 } },
        this.state.error.message
      );
    }

    var _state = this.state,
        __expr__ = _state.__expr__,
        __vars__ = _state.__vars__,
        hasError = _state.hasError,
        state = _objectWithoutProperties(_state, ['__expr__', '__vars__', 'hasError']);

    var _props2 = this.props,
        children = _props2.children,
        passThruProps = _objectWithoutProperties(_props2, ['children']);

    return React.Children.map(children, function (c, i) {
      return React.cloneElement(c, _extends({
        key: _this2.key + '-' + i
      }, state, passThruProps));
    });
  };

  return Wrapper;
}(React.PureComponent);

var getDerivedValues = function getDerivedValues(dVars) {
  var o = {};
  Object.keys(dVars).forEach(function (key) {
    return o[key] = dVars[key].value;
  });
  return o;
};

var IdyllDocument = function (_React$PureComponent2) {
  _inherits(IdyllDocument, _React$PureComponent2);

  function IdyllDocument(props) {
    _classCallCheck(this, IdyllDocument);

    var _this3 = _possibleConstructorReturn(this, _React$PureComponent2.call(this, props));

    _this3.scrollListener = _this3.scrollListener.bind(_this3);
    _this3.initScrollListener = _this3.initScrollListener.bind(_this3);

    var ast = filterASTForDocument(props.ast);

    var _splitAST = splitAST(ast),
        vars = _splitAST.vars,
        derived = _splitAST.derived,
        data = _splitAST.data,
        elements = _splitAST.elements;

    var initialState = _extends({}, getVars(vars), getData(data, props.datasets));
    var derivedVars = _this3.derivedVars = getVars(derived, initialState);

    var state = _this3.state = _extends({}, initialState, getDerivedValues(derivedVars));

    _this3.updateState = function (newState) {
      // merge new doc state with old
      var newMergedState = _extends({}, _this3.state, newState);
      // update derived values
      var newDerivedValues = getDerivedValues(getVars(derived, newMergedState));
      var nextState = _extends({}, newMergedState, newDerivedValues);
      var changedKeys = Object.keys(state).reduce(function (acc, k) {
        if (state[k] !== nextState[k]) acc.push(k);
        return acc;
      }, []);
      // Update doc state reference.
      // We re-use the same object here so that
      // IdyllDocument.state can be accurately checked in tests
      state = Object.assign(state, nextState);
      // pass the new doc state to all listeners aka component wrappers
      updatePropsCallbacks.forEach(function (f) {
        return f(state, changedKeys);
      });
    };

    evalContext.update = _this3.updateState;

    var rjs = new ReactJsonSchema(_extends({}, props.components, { Wrapper: Wrapper }));
    var schema = translate(ast);

    var wrapTargets = findWrapTargets(schema, _this3.state);

    var refCounter = 0;

    var transformedSchema = mapTree(schema, function (node) {
      if (typeof node === 'string') return node;

      // transform refs from strings to functions and store them
      if (node.ref || node.hasHook) {
        node.refName = node.ref || node.component + (refCounter++).toString();
        node.ref = function (el) {
          if (!el) return;
          var domNode = ReactDOM.findDOMNode(el);
          domNode.dataset.ref = node.refName;
          scrollOffsets[node.refName] = node.scrollOffset || 0;
          refCache[node.refName] = {
            props: node,
            domNode: domNode
          };
        };
      }

      if (!wrapTargets.includes(node)) return node;

      var component = node.component,
          children = node.children,
          key = node.key,
          _node$__vars__ = node.__vars__,
          __vars__ = _node$__vars__ === undefined ? {} : _node$__vars__,
          _node$__expr__ = node.__expr__,
          __expr__ = _node$__expr__ === undefined ? {} : _node$__expr__,
          props = _objectWithoutProperties(node, ['component', 'children', 'key', '__vars__', '__expr__']);

      // assign the initial values for tracked vars and expressions


      Object.keys(props).forEach(function (k) {
        if (__vars__[k]) {
          node[k] = state[__vars__[k]];
        }
        if (__expr__[k] && !__expr__[k].includes('refs.')) {
          if (hooks.indexOf(k) > -1) {
            return;
          }
          node[k] = evalExpression(state, __expr__[k], k, evalContext);
        }
      });

      // define the function wrapped components will call via this.props.updateProps
      node.updateProps = function (newProps) {
        // init new doc state object
        var newState = {};
        // iterate over passed in updates
        Object.keys(newProps).forEach(function (k) {
          // if a tracked var was updated get its new value
          if (__vars__[k]) {
            newState[__vars__[k]] = newProps[k];
          }
        });
        _this3.updateState(newState);
      };

      return {
        component: Wrapper,
        __vars__: __vars__,
        __expr__: __expr__,
        hasHook: node.hasHook,
        refName: node.refName,
        children: [node]
      };
    });

    _this3.kids = React.createElement(
      'div',
      { className: 'idyll-root', ref: _this3.initScrollListener },
      rjs.parseSchema(transformedSchema)
    );
    return _this3;
  }

  IdyllDocument.prototype.scrollListener = function scrollListener() {
    var _this4 = this;

    var refs = getRefs();
    updateRefsCallbacks.forEach(function (f) {
      return f(_extends({}, _this4.state, { refs: refs }));
    });
  };

  IdyllDocument.prototype.initScrollListener = function initScrollListener(el) {
    var _this5 = this;

    if (!el) return;

    var scroller = scrollparent(el);
    if (scroller === document.documentElement) {
      scroller = document.body;
    }
    scrollContainer = scrollMonitor.createContainer(scroller);
    Object.keys(refCache).forEach(function (key) {
      var _refCache$key = refCache[key],
          props = _refCache$key.props,
          domNode = _refCache$key.domNode;

      var watcher = scrollContainer.create(domNode, scrollOffsets[key]);
      hooks.forEach(function (hook) {
        if (props[hook]) {
          watcher[scrollMonitorEvents[hook]](function () {
            evalExpression(_this5.state, props[hook], hook, evalContext)();
          });
        }
      });
      scrollWatchers.push(watcher);
    });
    if (scroller === document.body) {
      scroller = window;
    }
    scroller.addEventListener('scroll', this.scrollListener);
  };

  IdyllDocument.prototype.updateDerivedVars = function updateDerivedVars(newState) {
    var _this6 = this;

    Object.keys(this.derivedVars).forEach(function (dv) {
      _this6.derivedVars[dv].value = _this6.derivedVars[dv].update(newState, _this6.state);
    });
  };

  IdyllDocument.prototype.getDerivedVars = function getDerivedVars() {
    var _this7 = this;

    var dvs = {};
    Object.keys(this.derivedVars).forEach(function (dv) {
      dvs[dv] = _this7.derivedVars[dv].value;
    });
    return dvs;
  };

  IdyllDocument.prototype.componentDidMount = function componentDidMount() {
    var _this8 = this;

    var refs = getRefs();
    updateRefsCallbacks.forEach(function (f) {
      return f(_extends({}, _this8.state, { refs: refs }));
    });
  };

  IdyllDocument.prototype.render = function render() {
    return this.kids;
  };

  return IdyllDocument;
}(React.PureComponent);

export default IdyllDocument;